h1. Doubleshot

At it's heart Doubleshot is a...

- Packaging tool := For mixed projects containing both Ruby and Java source code that you want to distribute as a Rubygem
- Build tool := To compile your Java source
- Dependency Manifest := Allowing you to declare dependencies for both Java JARs and Ruby Gems
- Dependency Installer := It will download dependencies and setup your Java classpaths and Ruby loadpaths
- Test Harness := Testing is integral to a good build, and Doubleshot aims to make mixed Java/Ruby language projects easier to test by recompiling and reloading your Java classes, and sandboxing your Ruby code

It's probably easiest to describe Doubleshot, by explaining what tools it replaces in your workflow:

h2. Doubleshot deprecates

* Bundler
* JBundler
* GemPackageTask
* RakeTestTask
* Maven Dependencies
* Maven Assemblies
* Build tools like Ant or Buildr

h1. Usage

h2. Installation

bc. gem install doubleshot

h2. Project Layout

The typical project using Doubleshot as it's build-tool will have the following layout:

* lib
  * java
    * Hello.java
  * ruby
    * world.rb
* test
  * helper.rb
  * hello_spec.rb
  * world_spec.rb
* Doubleshot
* hello_world.gemspec

Your tests should be executable and look something like this:

bc.. #!/usr/local/env jruby

require_relative "helper.rb"

describe org.sam.doubleshot.examples.Hello do
  it "must rock you" do
    org.sam.doubleshot.examples.Hello.you.must_equal "rock"
  end
end

p. ...and @helper.rb@ would look something like this:

bc.. require "doubleshot/build"
require "minitest/autorun"

h2. Testing Two Ways

h3. Direct Execution

p. Now you can execute your spec file directly and Doubleshot will:

# Ensure that the dependencies defined in the @./Doubleshot@ file are met by resolving their versions, downloading them, and adding them to your environment.
# Compile any code found in @lib/java@ that's not already compiled.

Then Minitest will run your test and exit when it's done.

h3. Sandbox Execution

Doubleshot also provides a @doubleshot@ bin file that basically amounts to @require("doubleshot/sandbox")@. Running @doubleshot@ in your project's home directory will setup monitors for @lib/@ and @test/@ and wait for changes, applying the rules below to it's execution:

* If any Java source under @lib/java@ changes, it will be recompiled, reloaded, and matching tests searched for to execute
* If any Ruby source under @lib@ changes, the testing sandbox that isolates your Ruby code will be reloaded, and matching tests executed
* If any tests change, the sandbox will be reloaded (since tests are written in Ruby), and the test file executed
* If a @SIGINT@ (@^C@) is received, all tests will be loaded and executed
* If a second @SIGINT@s is received before execution of the full test-suite is finished, the monitor will exit cleanly

This is the typical use-case for day to day development of new projects/features when using Doubleshot to manage your build process.

h2. Packaging

Given a project named _Example_, then @example.gemspec@ would include your Gem dependencies (including "doubleshot") and your @Doubleshot@ file would include both your Gem and JAR dependencies. This way your project is backwards compatible with Rubygems and Bundler. When packaging your project, your JAR dependencies will be "vendored" into the gem you've built.

Within your project (ie: @lib/example.rb@) you'll @require "doubleshot/setup"@. This will ensure any dependencies for your Gem are satisfied at runtime. If a dependency is already loaded, (an upstream project called @require "bundler/setup"@ for example) then Doubleshot will skip it.

If you're running inside of a @doubleshot/build@ then requiring @doublehsot/setup@ will have no effect.

To build a gem, run the @doubleshot build@ command on the command line. Doubleshot will ensure all dependencies are satisfied, compile your code, vendor any JAR dependencies, run your tests, and finally create a gem for you based on your @example.gemspec@ file. We really don't think you should be releasing code with broken tests so the build will fail if the tests don't pass (or bad tests skipped). If you _really_ want to skip this step though you can run @NOTEST=1 doubleshot build@.

h1. FAQ

h2. Where is @doubleshot show@?

Bundler includes a @bundle show some_gem@ command that shows you the path where a dependency was unpacked after running @bundle install@. I've only ever used that in two cases:

- View the source of some library to try to trace a bug := Write a test to trace your bug. View the source online or clone it and view it locally. It's a minor inconvenience sure, but it's a lot less prone to abuse.
- Hack in a quick "hot-fix" for a production issue := You shouldn't be making changes outside of source-control. That's an obvious development anti-pattern.

It's our opinion that you don't _need_ this functionality, and it opens the window to abuse, so we're not implementing it.

h2. Where is @doubleshot install@?

With Bundler it's common to:

# @bundle install@ to inspect your Gemfile and download/install any missing dependencies
# @require "bundler/setup"@ to check/require dependencies at runtime

With Doubleshot you'll:

bc. require "doubleshot/setup"

Doubleshot will first see if all it's dependencies are available, and if not, install any that are missing. So you don't have to manually run an installation step.

bq.. But I just want to install my Gem dependencies on a remote server and not actually attempt to run any code!
      *-- Said No One Ever*

p. If you _really_ want to pre-download your dependencies just run @jruby -r "doubleshot/setup"@ in your project's home-directory. Nothing to it.

h2. What if I want to create a unified JAR containing all my dependencies?

Use @doubleshot jar [main-class]@. By default the main-class will use JRuby's bootstrapping mechanism @org.jruby.JarBootstrapMain@, where you add your own @jar-bootstrap.rb@ file to be @require@d.

All gems will be unpacked and copied in. All JAR dependencies will be copied in as well.

This will leave you with an @example.jar@ you can just copy up to a server, and as long as a compatible version of Java is installed (typically Java6 or later), you have everything you need to run your application bundled in. Now you just need to run @java -jar example.jar@ and you're off to the races!

h2. Does Doubleshot support Ruby 1.8.x syntax?

No.

h1. TODO

* Build and release a doubleshot gem
* Get rid of Bundler and replace with our own Rubygem dependency resolution
* Get rid of JBundler and replace with our own Maven hooks
* Condense Gemfile and Jarfile into one unified Doubleshot file
* Compile .java sources on the fly and reload with Apache Commons JCI
* Use a file-system watcher to detect when .java sources should be recompiled so you never have to shutdown your java process
* Provide simplified helpers to create and reload Ruby ScriptingContainers to sandbox Ruby code
* Use above helpers in conjunction with a filesystem watcher to reload Ruby code when it's changed
* Provide build task to use a gemspec, package the jars in the gem, and require them for you

h1. NOTES

h2. CLASSPATH

If you @require("path/to/some.jar")@, all JRuby is doing is modifying your _CLASSPATH_ so later references to a Class can locate the Class. Unlike Rubygems, it's not actually auto-requiring any code for you.

Your compiled code will also need to be added to the CLASSPATH. This can be accomplished by simply adding the output directory:

bc.. require "java"
$CLASSPATH << "target"
org.foo.Bar.baz
# => "SUCCESS!"

h2. Program Execution

Since Doubleshot is a build tool, we assume your entry-point is always JRuby and not a Java class of your own making (since there would be no compiled version of it for you to execute yet).

h2. Example

bc.. $ git clone git://github.com/sam/doubleshot.git
$ cd doubleshot
$ jruby -r lib/doubleshot/build.rb -e "p org.foo.Bar.baz"
# SUCCESS!

p. If you look under @lib/java/Bar.java@ you'll notice the @baz@ method just returns _"SUCCESS!"_, which is the output you're seeing there.