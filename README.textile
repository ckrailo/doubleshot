h1. Doubleshot

h2. Overview

bc. gem install doubleshot

Doubleshot is intended to simplify your build process when you have a combination of dependencies including both _JARs_ and _Gems_, and source code that includes both @.java@ files and @.rb@ code.

During testing or packaging of your project you'll want to @require "doubleshot/build"@. If you have your @Jarfile@ and @Gemfile@ setup correctly, this will be all you need to resolve your dependencies, compile your Java, and ensure your @CLASSPATH@ is setup correctly.

When actually using your packaged library, all you should need is @require "doubleshot/setup"@, which will skip the build process.

*NOTE:* Below we'll provide an overview of the basic implementation of the _Doubleshot_ library. These are mostly our own development notes.

h2. Dependencies

h3. Gems

Using Bundler, and an existing @Gemfile@, the following code will setup our dependencies, and install them on demand if necessary:

bc.. begin
  require "bundler/setup"
rescue LoadError
  require "bundler/cli"
  Bundler::CLI.new.install
  retry
end

p. *NOTE:* Do make sure that @gem "jbundler"@ is the first entry in your @Gemfile@ if you also plan to have _JAR_ dependencies (described below).

h3. JARs

Using JBundler and a @Jarfile@ you'll be able to install dependencies from Maven repositories like so:

bc.. require "bundler"
require "jbundler/cli"
JBundler::Cli.new.install

h2. Java Compilation

Using JRuby's built-in Ant support, classes can be compiled on-the-fly:

bc.. require "ant"
ant.javac srcdir: ".", destdir: "target", debug: "yes", includeantruntime: "no"

p. Building on that, you could check @Pathname(target_file).file?@ to see if a Class is already compiled, and compare with the source @Pathname(source_file).mtime > Pathname(target_file).mtime@ to see if it needs to be recompiled because the source has changed.

For a bit more sophistication, something like the Apache Commons JCI and FAM might allow you to reload the java classes as well so you don't need to restart your Java process during development.

h2. CLASSPATH

If you @require("path/to/some.jar")@, all JRuby is doing is modifying your _CLASSPATH_ so later references to a Class can locate the Class. Unlike Rubygems, it's not actually auto-requiring any code for you.

Your compiled code will also need to be added to the CLASSPATH. This can be accomplished by simply adding the output directory:

bc.. require "java"
$CLASSPATH << "target"
org.foo.Bar.baz
# => 1

h2. Packaging

Your project has a mix of Java and Ruby code and is intended to be consumed by other projects running on JRuby. It doesn't make much sense to release a JAR since it would include Ruby. You'll want to package as a Gem.

Since gemspecs don't support Java JARs, you'll want to add the JARs to your Gem. Yes, this will bloat the size of your Gem significantly, but there's no real alternative unless you want to force downstream users to use something like JBundler themselves.

So just keep in mind that you'll need to drop your JAR dependencies into a @./jars/@ folder or some-such, and require them from that location in you packaged Gem.